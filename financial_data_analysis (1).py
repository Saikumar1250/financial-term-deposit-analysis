# -*- coding: utf-8 -*-
"""Financial_data_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17nSEsIINENIo474HJ5kj3zwr1luqQnlN

# **Data-Driven Customer Targeting: Enhancing Term Deposit Campaign Success in Financial Services**
"""

#Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#Import Data
df=pd.read_csv("/content/Financial data.csv")

#Print the first 10 rows of the data
df.head(10)

#show the descriptie statistics of the data
df.describe()

# Drop the empty column
df = df.drop(columns=['Unnamed: 21'])

"""# **Data Visualisation**"""

#Count of the target variable
plt.figure(figsize=(6, 4))
sns.countplot(x='y', data=df)
plt.title('Subscription Status Distribution')
plt.show()

#Distribution of age
plt.figure(figsize=(8, 5))
plt.hist(df['age'], bins=10, color='skyblue', edgecolor='black')
plt.title('Age Distribution')
plt.xlabel('Age')
plt.ylabel('Number of Records')
plt.show()

# Scatterplot of Age vs Duration by Subscription Status
# Create age bins
df['age_group'] = pd.cut(df['age'], bins=[15, 25, 35, 45, 55, 65, 100],
                         labels=['15-25', '26-35', '36-45', '46-55', '56-65', '65+'])

plt.figure(figsize=(10, 6))
sns.boxplot(x='age_group', y='duration', hue='y', data=df)
plt.title('Call Duration by Age Group and Subscription Status')
plt.xlabel('Age Group')
plt.ylabel('Call Duration(in Seconds)')
plt.show()

#line plot of Average call duration by Day of Week.
avg_duration_by_day = df.groupby('day_of_week')['duration'].mean()
plt.figure(figsize=(8, 5))
plt.plot(avg_duration_by_day.index, avg_duration_by_day.values, marker='o', linestyle='-', color='darkorange')
plt.title('Average Call Duration by Day of Week')
plt.xlabel('Day of Week')
plt.ylabel('Average Duration')
plt.grid(True)
plt.show()

# Subscription Rate by Job Role
plt.figure(figsize=(10, 5))
job_order = df['job'].value_counts().index
sns.countplot(data=df, y='job', hue='y', order=job_order)
plt.title("Subscription by Job Role")
plt.xlabel("Count")
plt.ylabel("Job")
plt.legend(title="Subscribed")
plt.tight_layout()
plt.show()

#bar plot of Job category distribution.
job_counts = df['job'].value_counts()
plt.figure(figsize=(10, 6))
plt.barh(job_counts.index, job_counts.values, color='red')
plt.xlabel('Number of Customers')
plt.title('Job Category Distribution')
plt.grid(axis='x')
plt.show()

# Distribution of Subscription Status  by Marital Status
plt.figure(figsize=(8, 5))
sns.countplot(data=df, x='marital', hue='y')
plt.title("Marital Status vs Subscription")
plt.xlabel("Marital Status")
plt.ylabel("Count")
plt.legend(title="Subscribed")
plt.tight_layout()
plt.show()

# Monthly distribution of Subscriptions.
plt.figure(figsize=(10, 5))
month_order = ['jan', 'feb', 'mar', 'apr', 'may', 'jun',
               'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
sns.countplot(data=df, x='month', hue='y', order=month_order)
plt.title("Monthly Distribution of Subscriptions")
plt.xlabel("Month")
plt.ylabel("Count")
plt.legend(title="Subscribed")
plt.tight_layout()
plt.show()

"""# **Regression Analysis**"""

#Importing libraries for Regression analysis.
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, mean_squared_error, r2_score

# Encode target variable
df['y'] = df['y'].map({'no': 0, 'yes': 1})

# Select impactful variables
vars = [
    'duration', 'pdays', 'previous', 'emp.var.rate',
    'euribor3m', 'nr.employed', 'contact', 'month', 'poutcome', 'y'
]
df_model = df[vars].copy()

# Encode categorical variables
contact_encoder = LabelEncoder().fit(df_model['contact'])
month_encoder = LabelEncoder().fit(df_model['month'])
poutcome_encoder = LabelEncoder().fit(df_model['poutcome'])

df_model['contact'] = contact_encoder.transform(df_model['contact'])
df_model['month'] = month_encoder.transform(df_model['month'])
df_model['poutcome'] = poutcome_encoder.transform(df_model['poutcome'])

# Define features and target variables
X = df_model.drop('y', axis=1)
y = df_model['y']

# Split the dataset into training and testing sets (80% training, 20% testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=True)

# Train models
log_model = LogisticRegression(max_iter=1000)
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)

log_model.fit(X_train, y_train)
rf_model.fit(X_train, y_train)

# Predictions
y_pred_log = log_model.predict(X_test)
y_pred_rf = rf_model.predict(X_test)

# Evaluation
print("Logistic Regression:")
print(f"Accuracy: {accuracy_score(y_test, y_pred_log):.4f}")
print(f"R2 Score: {r2_score(y_test, y_pred_log):.4f}")
print(f"MSE: {mean_squared_error(y_test, y_pred_log):.4f}")

print("\nRandom Forest:")
print(f"Accuracy: {accuracy_score(y_test, y_pred_rf):.4f}")
print(f"R2 Score: {r2_score(y_test, y_pred_rf):.4f}")
print(f"MSE: {mean_squared_error(y_test, y_pred_rf):.4f}")

# Sample input for prediction
sample_input = pd.DataFrame({
    'duration': [350],
    'pdays': [999],
    'previous': [0],
    'emp.var.rate': [1.1],
    'euribor3m': [4.857],
    'nr.employed': [5191.0],
    'contact': [contact_encoder.transform(['cellular'])[0]],
    'month': [month_encoder.transform(['may'])[0]],
    'poutcome': [poutcome_encoder.transform(['nonexistent'])[0]]
})

# Predict sample
log_pred = log_model.predict(sample_input)[0]
rf_pred = rf_model.predict(sample_input)[0]

print("\nSample Prediction (Customer Profile):")
print(f"Logistic Regression Prediction: {'yes' if log_pred == 1 else 'no'}")
print(f"Random Forest Prediction: {'yes' if rf_pred == 1 else 'no'}")

